"""
Exploit Probability Model
==========================

Bayesian model for estimating the probability that a given CVE
vulnerability will be exploited in the wild. Uses empirical base rates
from vulnerability exploitation research and updates the prior based
on observable characteristics of the vulnerability.

The model draws on the work of Allodi & Massacci (2014) who demonstrated
that only a small fraction of published vulnerabilities are actually
exploited, and that exploitation probability varies significantly
based on vulnerability characteristics.

Model Architecture:
    1. Set prior probability based on severity-derived base rates.
    2. Compute likelihood ratios for each observable evidence factor.
    3. Apply sequential Bayesian updating via the odds form of
       Bayes' theorem to produce a posterior exploitation probability.

Evidence Factors and Likelihood Ratios:
    - Network accessibility: 2.5x (remote attacks far more common)
    - No authentication required: 2.0x (lower barrier to exploitation)
    - Low attack complexity: 1.8x (easier to weaponise)
    - Public exploit available: 5.0x (script-kiddie amplification)
    - Active exploitation reported: 8.0x (known threat actor use)
    - Age < 30 days: 3.0x (fresh vulnerabilities attract attention)
    - Age < 90 days: 2.0x
    - Age < 365 days: 1.5x

References:
    - Allodi, L., & Massacci, F. (2014). Comparing Vulnerability Severity
      and Exploits Using Case-Control Studies. ACM CCS 2014.
    - Bozorgi, M., Saul, L. K., Savage, S., & Voelker, G. M. (2010).
      Beyond Heuristics: Learning to Classify Vulnerabilities and Predict
      Exploits. KDD 2010, 105-114.
    - Jacobs, J., Romanosky, S., Adjerid, I., & Baker, W. (2020).
      Improving Vulnerability Remediation Through Better Exploit
      Prediction. Journal of Cybersecurity, 6(1).
    - FIRST. (2023). Exploit Prediction Scoring System (EPSS).
      https://www.first.org/epss/
"""

from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional

from shared.math_utils import bayesian_update

from nexus.core.models import (
    AttackComplexity,
    AttackVector,
    CVERecord,
    CVSSVector,
    PrivilegesRequired,
    UserInteraction,
)


class ExploitProbabilityModel:
    """Bayesian exploitation probability estimator.

    Estimates the probability that a vulnerability will be exploited
    using a Bayesian framework that combines empirical base rates
    with observable vulnerability characteristics.

    The prior is calibrated from empirical exploitation rates reported
    in Allodi & Massacci (2014):
        - Critical severity: ~15% exploitation rate
        - High severity:     ~8% exploitation rate
        - Medium severity:   ~3% exploitation rate
        - Low severity:      ~1% exploitation rate

    Attributes:
        base_rates: Severity-to-prior-probability mapping.
        likelihood_factors: Evidence factor name-to-ratio mapping.

    Usage::

        model = ExploitProbabilityModel()
        prob = model.calculate(cve_record)
        print(f"Exploitation probability: {prob:.2%}")
    """

    # Empirical base rates by severity category
    # From Allodi & Massacci (2014) Table 3
    BASE_RATES: dict[str, float] = {
        "critical": 0.15,
        "high": 0.08,
        "medium": 0.03,
        "low": 0.01,
        "none": 0.005,
        "unknown": 0.02,
    }

    # Likelihood ratios for each evidence factor
    # These represent P(evidence | exploited) / P(evidence | not exploited)
    FACTOR_NETWORK_ACCESSIBLE: float = 2.5
    FACTOR_NO_AUTH_REQUIRED: float = 2.0
    FACTOR_LOW_COMPLEXITY: float = 1.8
    FACTOR_PUBLIC_EXPLOIT: float = 5.0
    FACTOR_ACTIVE_EXPLOITATION: float = 8.0
    FACTOR_AGE_UNDER_30_DAYS: float = 3.0
    FACTOR_AGE_UNDER_90_DAYS: float = 2.0
    FACTOR_AGE_UNDER_365_DAYS: float = 1.5
    FACTOR_NO_USER_INTERACTION: float = 1.5
    FACTOR_HIGH_IMPACT: float = 1.4

    def __init__(
        self,
        custom_base_rates: Optional[dict[str, float]] = None,
    ) -> None:
        """Initialise the exploitation probability model.

        Args:
            custom_base_rates: Optional override of default base rates.
                               Keys are severity levels, values are
                               prior probabilities in (0, 1).
        """
        self.base_rates = dict(self.BASE_RATES)
        if custom_base_rates:
            self.base_rates.update(custom_base_rates)

    def calculate(
        self,
        cve: CVERecord,
        parsed_vector: Optional[CVSSVector] = None,
        reference_date: Optional[datetime] = None,
    ) -> float:
        """Calculate the exploitation probability for a CVE.

        Performs sequential Bayesian updating starting from the
        severity-based prior, incorporating all observable evidence
        factors to produce a posterior exploitation probability.

        The computation follows the odds form of Bayes' theorem:
            posterior_odds = prior_odds * prod(likelihood_ratios)
            P(exploit | evidence) = posterior_odds / (1 + posterior_odds)

        Reference:
            Allodi, L., & Massacci, F. (2014). Comparing Vulnerability
            Severity and Exploits Using Case-Control Studies. Section 4.

        Args:
            cve: The CVERecord to analyse.
            parsed_vector: Optional pre-parsed CVSSVector. If None,
                          the vector is extracted from cve.cvss_vector.
            reference_date: Reference date for age calculations.
                           Defaults to current UTC time.

        Returns:
            Exploitation probability in [0.0, 1.0].
        """
        # Step 1: Determine prior from severity
        severity = cve.severity.lower() if cve.severity else "unknown"
        prior = self.base_rates.get(severity, self.BASE_RATES["unknown"])

        # Step 2: Collect likelihood ratios from evidence
        likelihood_ratios: list[float] = []

        # Parse CVSS vector if available
        vector = parsed_vector
        if vector is None and cve.cvss_vector:
            try:
                from nexus.analyzers.cvss import CVSSCalculator
                calc = CVSSCalculator()
                vector = calc.parse_vector(cve.cvss_vector)
            except (ValueError, ImportError):
                vector = None

        if vector is not None:
            # Network accessibility factor
            if vector.attack_vector == AttackVector.NETWORK:
                likelihood_ratios.append(self.FACTOR_NETWORK_ACCESSIBLE)

            # No authentication required factor
            if vector.privileges_required == PrivilegesRequired.NONE:
                likelihood_ratios.append(self.FACTOR_NO_AUTH_REQUIRED)

            # Low attack complexity factor
            if vector.attack_complexity == AttackComplexity.LOW:
                likelihood_ratios.append(self.FACTOR_LOW_COMPLEXITY)

            # No user interaction factor
            if vector.user_interaction == UserInteraction.NONE:
                likelihood_ratios.append(self.FACTOR_NO_USER_INTERACTION)

            # High impact factor (any CIA dimension is High)
            from nexus.core.models import Impact
            if any(
                getattr(vector, dim) == Impact.HIGH
                for dim in ("confidentiality", "integrity", "availability")
            ):
                likelihood_ratios.append(self.FACTOR_HIGH_IMPACT)

        # Public exploit availability factor
        if cve.has_public_exploit:
            likelihood_ratios.append(self.FACTOR_PUBLIC_EXPLOIT)

        # Active exploitation factor
        if cve.is_actively_exploited:
            likelihood_ratios.append(self.FACTOR_ACTIVE_EXPLOITATION)

        # Age-based factor
        age_factor = self._compute_age_factor(cve, reference_date)
        if age_factor > 1.0:
            likelihood_ratios.append(age_factor)

        # Step 3: Bayesian update
        if not likelihood_ratios:
            return prior

        posterior = bayesian_update(prior, likelihood_ratios)

        return round(posterior, 4)

    def _compute_age_factor(
        self,
        cve: CVERecord,
        reference_date: Optional[datetime] = None,
    ) -> float:
        """Compute the age-based likelihood ratio.

        Newer vulnerabilities are more likely to be exploited due to
        the window of opportunity before patches are widely deployed.

        Reference:
            Jacobs, J., et al. (2020). Improving Vulnerability
            Remediation Through Better Exploit Prediction. Section 4.2.

        Args:
            cve: CVERecord with published_date.
            reference_date: Date to compute age from. Defaults to now.

        Returns:
            Likelihood ratio >= 1.0 based on vulnerability age.
        """
        if not cve.published_date:
            return 1.0

        try:
            # Handle multiple date formats
            pub_date_str = cve.published_date
            pub_date: Optional[datetime] = None

            for fmt in (
                "%Y-%m-%dT%H:%M:%S.%fZ",
                "%Y-%m-%dT%H:%M:%S",
                "%Y-%m-%dT%H:%M:%SZ",
                "%Y-%m-%d",
            ):
                try:
                    pub_date = datetime.strptime(pub_date_str, fmt).replace(
                        tzinfo=timezone.utc
                    )
                    break
                except ValueError:
                    continue

            if pub_date is None:
                return 1.0

            ref = reference_date or datetime.now(timezone.utc)
            if ref.tzinfo is None:
                ref = ref.replace(tzinfo=timezone.utc)

            age_days = (ref - pub_date).days

            if age_days < 0:
                return 1.0
            elif age_days < 30:
                return self.FACTOR_AGE_UNDER_30_DAYS
            elif age_days < 90:
                return self.FACTOR_AGE_UNDER_90_DAYS
            elif age_days < 365:
                return self.FACTOR_AGE_UNDER_365_DAYS
            else:
                return 1.0

        except (ValueError, TypeError):
            return 1.0

    def explain(
        self,
        cve: CVERecord,
        parsed_vector: Optional[CVSSVector] = None,
        reference_date: Optional[datetime] = None,
    ) -> dict[str, object]:
        """Provide a detailed explanation of the probability calculation.

        Returns a breakdown of the prior, each evidence factor with
        its likelihood ratio, and the final posterior probability.

        Useful for generating audit trails and human-readable reports.

        Args:
            cve: The CVERecord to analyse.
            parsed_vector: Optional pre-parsed CVSSVector.
            reference_date: Reference date for age calculations.

        Returns:
            Dictionary with keys: prior, factors (list of dicts),
            posterior, and severity.
        """
        severity = cve.severity.lower() if cve.severity else "unknown"
        prior = self.base_rates.get(severity, self.BASE_RATES["unknown"])

        factors: list[dict[str, object]] = []

        # Parse vector
        vector = parsed_vector
        if vector is None and cve.cvss_vector:
            try:
                from nexus.analyzers.cvss import CVSSCalculator
                calc = CVSSCalculator()
                vector = calc.parse_vector(cve.cvss_vector)
            except (ValueError, ImportError):
                vector = None

        likelihood_ratios: list[float] = []

        if vector is not None:
            if vector.attack_vector == AttackVector.NETWORK:
                lr = self.FACTOR_NETWORK_ACCESSIBLE
                factors.append({
                    "name": "Network Accessible",
                    "description": "Vulnerability is exploitable over the network",
                    "likelihood_ratio": lr,
                })
                likelihood_ratios.append(lr)

            if vector.privileges_required == PrivilegesRequired.NONE:
                lr = self.FACTOR_NO_AUTH_REQUIRED
                factors.append({
                    "name": "No Authentication Required",
                    "description": "No privileges needed to exploit",
                    "likelihood_ratio": lr,
                })
                likelihood_ratios.append(lr)

            if vector.attack_complexity == AttackComplexity.LOW:
                lr = self.FACTOR_LOW_COMPLEXITY
                factors.append({
                    "name": "Low Attack Complexity",
                    "description": "Attack conditions are not specialised",
                    "likelihood_ratio": lr,
                })
                likelihood_ratios.append(lr)

            if vector.user_interaction == UserInteraction.NONE:
                lr = self.FACTOR_NO_USER_INTERACTION
                factors.append({
                    "name": "No User Interaction",
                    "description": "Exploitation requires no user action",
                    "likelihood_ratio": lr,
                })
                likelihood_ratios.append(lr)

            from nexus.core.models import Impact
            if any(
                getattr(vector, dim) == Impact.HIGH
                for dim in ("confidentiality", "integrity", "availability")
            ):
                lr = self.FACTOR_HIGH_IMPACT
                factors.append({
                    "name": "High Impact",
                    "description": "At least one CIA dimension has High impact",
                    "likelihood_ratio": lr,
                })
                likelihood_ratios.append(lr)

        if cve.has_public_exploit:
            lr = self.FACTOR_PUBLIC_EXPLOIT
            factors.append({
                "name": "Public Exploit Available",
                "description": "Exploit code is publicly available",
                "likelihood_ratio": lr,
            })
            likelihood_ratios.append(lr)

        if cve.is_actively_exploited:
            lr = self.FACTOR_ACTIVE_EXPLOITATION
            factors.append({
                "name": "Active Exploitation",
                "description": "Vulnerability is being actively exploited",
                "likelihood_ratio": lr,
            })
            likelihood_ratios.append(lr)

        age_factor = self._compute_age_factor(cve, reference_date)
        if age_factor > 1.0:
            factors.append({
                "name": "Recency",
                "description": "Vulnerability was recently published",
                "likelihood_ratio": age_factor,
            })
            likelihood_ratios.append(age_factor)

        if likelihood_ratios:
            posterior = bayesian_update(prior, likelihood_ratios)
        else:
            posterior = prior

        return {
            "severity": severity,
            "prior": round(prior, 4),
            "factors": factors,
            "posterior": round(posterior, 4),
            "factor_count": len(factors),
        }
